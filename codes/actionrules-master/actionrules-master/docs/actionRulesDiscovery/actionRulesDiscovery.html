<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>actionrules.actionRulesDiscovery.actionRulesDiscovery API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>actionrules.actionRulesDiscovery.actionRulesDiscovery</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import List
import pandas as pd

from actionrules.desiredState import DesiredState
from actionrules.decisions import Decisions
from actionrules.reduction import Reduction
from actionrules.actionRules import ActionRules


class ActionRulesDiscovery:
    &#34;&#34;&#34;
    The class ActionRulesDiscovery is the main control class where the methods fit or
    predict can be called. However, there is a minimum logic in the class. It is just an
    interface that initializes other objects and calls their methods.

    ...

    Attributes
    ----------
    decisions : Decisions()
        Object that runs PyFIM classification rules discovery.
    action_rules: None or ActionRules
        Object that runs action rules discovery.
    desired_state: DesiredState
        Object that is responsible for handling of desired state.
    stable_attributes: list
        List of stable attributes.
    flexible_attributes: list
        List of flexible attributes.
    consequent: str
        Name of consequent columns.

    Methods
    -------
    read_csv(self, file: str, **kwargs)
        Import data from a CSV file.
    load_pandas(self, data_frame: pd.DataFrame)
        Import data from Pandas data frame.
    fit(self,
        stable_attributes: List[str],
        flexible_attributes: List[str],
        consequent: str,
        conf: float,
        supp: float,
        desired_classes: List[str] = None,
        desired_changes: List[list] = None,
        is_nan: bool = False,
        is_reduction: bool = True,
        min_stable_attributes: int = 1,
        min_flexible_attributes: int = 1,
        max_stable_attributes: int = 5,
        max_flexible_attributes: int = 5,
        )
        Train the model from transaction data.
    fit_classification_rules(self,
                             stable_attributes: List[str],
                             flexible_attributes: List[str],
                             consequent: str,
                             conf_col: str,
                             supp_col: str,
                             desired_classes: List[str] = None,
                             desired_changes: List[list] = None,
                             is_nan: bool = False,
                             is_reduction: bool = True,
                             min_stable_attributes: int = 1,
                             min_flexible_attributes: int = 1,
                             max_stable_attributes: int = 5,
                             max_flexible_attributes: int = 5,
                             )
        Train the model from classification rules.
    get_action_rules(self) -&gt; list
        Get list of action rules (machine representation)
    get_pretty_action_rules(self) -&gt; list
        Get human-readable representations of action rules
    get_action_rules_representation(self) -&gt; list
        Get math representation of action rules
    get_source_data_for_ar(self, action_r_number: int, is_before: bool) -&gt; pd.DataFrame
        Get the source data the action rule is discovered from.
    predict(self, source_table: pd.DataFrame) -&gt; pd.DataFrame
        Predicts if new occurrence would need any change.

    &#34;&#34;&#34;
    ACTION_RULE = &#34;action rule&#34;
    ACTION_RULE_TARGET = &#34;action rule target&#34;
    SUPPORT_BEFORE = &#34;support before&#34;
    SUPPORT_AFTER = &#34;support after&#34;
    ACTION_RULE_SUPPORT = &#34;action rule support&#34;
    CONFIDENCE_BEFORE = &#34;confidence before&#34;
    CONFIDENCE_AFTER = &#34;confidence after&#34;
    ACTION_RULE_CONFIDENCE = &#34;action rule confidence&#34;
    ACTION_RULE_UPLIFT = &#34;uplift&#34;
    RECOMMENDED = &#34;-recommended&#34;

    def __init__(self):
        &#34;&#34;&#34;
        Initialise
        &#34;&#34;&#34;
        self.decisions = Decisions()
        self.action_rules = None
        self.desired_state = None
        self.stable_attributes = []
        self.flexible_attributes = []
        self.consequent = &#34;&#34;

    def _check_columns(self, attributes: List[str], consequent: str):
        &#34;&#34;&#34;Checks if inserted data is valid (columns exist, rows exist).

        Parameters
        ----------
        attributes : List[str]
            List of attributes names.
        consequent : str
            The name of consequent.

        Raises
        ------
        Exception
            If no data entered or column does not exist in data.
        &#34;&#34;&#34;
        if len(self.decisions.data) == 0:
            raise Exception(&#34;No data entered.&#34;)
        columns = self.decisions.data.columns
        for col_name in attributes + [consequent]:
            if col_name not in columns:
                raise Exception(&#34;Column &#34; + str(col_name) + &#34; does not exist in data&#34;)

    def read_csv(self, file: str, **kwargs):
        &#34;&#34;&#34;Imports data from a CSV file.

        It uses the same optional parameters as read_csv from Pandas.

        Parameters
        ----------
        file : str
            A path to a file.
        **kwargs :
            Arbitrary keyword arguments (the same as in Pandas).
        &#34;&#34;&#34;
        self.decisions.read_csv(file, **kwargs)

    def load_pandas(self, data_frame: pd.DataFrame):
        &#34;&#34;&#34;Loads a data frame.

        It must be the Pandas data frame.

        Parameters
        ----------
        data_frame : pd.DataFrame
            Pandas data frame.
        &#34;&#34;&#34;
        self.decisions.load_pandas(data_frame)

    def fit(self,
            stable_attributes: List[str],
            flexible_attributes: List[str],
            consequent: str,
            conf: float,
            supp: float,
            desired_classes: List[str] = None,
            desired_changes: List[list] = None,
            is_nan: bool = False,
            is_reduction: bool = True,
            min_stable_attributes: int = 1,
            min_flexible_attributes: int = 1,
            max_stable_attributes: int = 5,
            max_flexible_attributes: int = 5,
            ):
        &#34;&#34;&#34;Train the model from transaction data.

        Define antecedent and consequent.
        - stable_attributes
        - flexible_attributes
        - consequent
        Confidence and support.
        - conf
        - supp
        Desired classes or desired changes must be entered.
        - desired_classes
        - desired_changes
        Should NaN values be used?
        - is_nan
        Should the reduction table be used?
        - is_reduction
        Minimal number of stable and flexible pairs in antecedent.
        - min_stable_attributes
        - min_flexible_attributes
        - max_stable_attributes
        - max_flexible_attributes

        Parameters
        ----------
        stable_attributes : List[str]
            List of column names.
        flexible_attributes : List[str]
            List of column names.
        consequent : str
            Name of the consequent column.
        conf : float
            Value in % for minimal confidence in classification rules.
            For example, 60.
        supp : float
            Value in % for minimal support of classification rules.
            For example, 5.
        desired_classes : List[str] = None
            List of decision states. For example, [&#34;1&#34;].
            DEFAULT: None
        desired_changes : List[list] = None
            List of desired changes. For example, [[&#34;0&#34;, &#34;1&#34;]].
            DEFAULT: None
        is_nan : bool = False
            True means NaN values are used, False means NaN values are not used.
            It means NaN values from classification rules.
            DEFAULT: FALSE
        is_reduction : bool = True
            Is the reduction table used?
            DEFAULT: TRUE
        min_stable_attributes : int = 1
            Minimal number of stable pairs.
            DEFAULT: 1
        min_flexible_attributes : int = 1
            Minimal number of flexible pairs.
            DEFAULT: 1
        max_stable_attributes : int = 5
            Maximal number of stable pairs.
            DEFAULT: 5
        max_flexible_attributes : int = 5
            Maximal number of flexible pairs.
            DEFAULT: 5
        &#34;&#34;&#34;
        if (self.action_rules):
            raise Exception(&#34;Fit was already called&#34;)
        self.stable_attributes = stable_attributes
        self.flexible_attributes = flexible_attributes
        self.consequent = consequent
        if bool(desired_classes) != bool(desired_changes):
            self.desired_state = DesiredState(desired_classes=desired_classes, desired_changes=desired_changes)
        else:
            raise Exception(&#34;Desired classes or desired changes must be entered&#34;)
        attributes = stable_attributes + flexible_attributes
        self._check_columns(attributes, consequent)
        self.decisions.prepare_data_fim(attributes, consequent)
        self.decisions.fit_fim_apriori(conf=conf, support=supp)
        self.decisions.generate_decision_table()
        stable = self.decisions.decision_table[stable_attributes]
        flex = self.decisions.decision_table[flexible_attributes]
        target = self.decisions.decision_table[[consequent]]
        supp = self.decisions.support
        conf = self.decisions.confidence
        reduced_tables = Reduction(stable, flex, target, self.desired_state, supp, conf, is_nan)
        if is_reduction:
            reduced_tables.reduce()
        self.action_rules = ActionRules(
            reduced_tables.stable_tables,
            reduced_tables.flexible_tables,
            reduced_tables.decision_tables,
            self.desired_state,
            reduced_tables.supp,
            reduced_tables.conf,
            is_nan,
            min_stable_attributes,
            min_flexible_attributes,
            max_stable_attributes,
            max_flexible_attributes
        )
        self.action_rules.fit()

    def fit_classification_rules(self,
                                 stable_attributes: List[str],
                                 flexible_attributes: List[str],
                                 consequent: str,
                                 conf_col: str,
                                 supp_col: str,
                                 desired_classes: List[str] = None,
                                 desired_changes: List[list] = None,
                                 is_nan: bool = False,
                                 is_reduction: bool = True,
                                 min_stable_attributes: int = 1,
                                 min_flexible_attributes: int = 1,
                                 max_stable_attributes: int = 5,
                                 max_flexible_attributes: int = 5,
                                 ):
        &#34;&#34;&#34;Train the model from classification rules.

        Define antecedent and consequent.
        - stable_attributes
        - flexible_attributes
        - consequent
        Confidence and support.
        - conf_col
        - supp_col
        Desired classes or desired changes must be entered.
        - desired_classes
        - desired_changes
        Should NaN values be used?
        - is_nan
        Should the reduction table be used?
        - is_reduction
        Minimal number of stable and flexible pairs in antecedent.
        - min_stable_attributes
        - min_flexible_attributes
        - max_stable_attributes
        - max_flexible_attributes

        Parameters
        ----------
        stable_attributes: List[str]
            List of column names.
        flexible_attributes: List[str]
            List of column names.
        consequent: str
            Name of the consequent column.
        conf_col: str
            Name of the column with classification rule confidence -
            the numbers should be in form 0.1 for 10%.
        supp_col: str
            Name of the column with classification rule support -
            the numbers should be in form 0.1 for 10%.
        desired_classes: List[str] = None
            List of decision states. For example [&#34;1&#34;].
            DEFAULT: None
        desired_changes: List[list] = None
            List of desired changes. For example [[&#34;0&#34;, &#34;1&#34;]].
            DEFAULT: None
        is_nan: bool = False
            True means NaN values are used, False means nan values are not used.
            DEFAULT: FALSE
        is_reduction: bool = True
            Is the reduction table used?
            DEFAULT: TRUE
        min_stable_attributes: int = 1
            Minimal number of stable pairs.
            DEFAULT: 1
        min_flexible_attributes: int = 1
            Minimal number of flexible pairs.
            DEFAULT: 1
        max_stable_attributes: int = 5
            Maximal number of stable pairs.
            DEFAULT: 5
        max_flexible_attributes: int = 5
            Maximal number of flexible pairs.
            DEFAULT: 5
        &#34;&#34;&#34;
        if (self.action_rules):
            raise Exception(&#34;Fit was already called&#34;)
        self.stable_attributes = stable_attributes
        self.flexible_attributes = flexible_attributes
        self.consequent = consequent
        if bool(desired_classes) != bool(desired_changes):
            self.desired_state = DesiredState(desired_classes=desired_classes, desired_changes=desired_changes)
        else:
            raise Exception(&#34;Desired classes or desired changes must be entered&#34;)
        attributes = stable_attributes + flexible_attributes
        self._check_columns(attributes, consequent)
        stable = self.decisions.data[stable_attributes]
        flex = self.decisions.data[flexible_attributes]
        target = self.decisions.data[[consequent]]
        supp_df = self.decisions.data[[supp_col]]
        supp_series = supp_df.iloc[:, 0]
        supp = supp_series.tolist()
        conf_df = self.decisions.data[[conf_col]]
        conf_series = conf_df.iloc[:, 0]
        conf = conf_series.tolist()
        reduced_tables = Reduction(stable, flex, target, self.desired_state, supp, conf, is_nan)
        if is_reduction:
            reduced_tables.reduce()
        self.action_rules = ActionRules(
            reduced_tables.stable_tables,
            reduced_tables.flexible_tables,
            reduced_tables.decision_tables,
            self.desired_state,
            reduced_tables.supp,
            reduced_tables.conf,
            is_nan,
            min_stable_attributes,
            min_flexible_attributes,
            max_stable_attributes,
            max_flexible_attributes
        )
        self.action_rules.fit()

    def get_action_rules(self) -&gt; list:
        &#34;&#34;&#34;Get machine representations of action rules.

        The output is a list of action
        rules. Each action rule is a list where the first part is an action rule itself, and the second part is
        a tuple of (support before, support after, action rule support), (confidence before, confidence after, action
        rule confidence) and uplift.

        Returns
        -------
        list
            Returns list of action rules.
        &#34;&#34;&#34;
        return self.action_rules.action_rules

    def get_pretty_action_rules(self) -&gt; list:
        &#34;&#34;&#34;Get human-readable representations of action rules.

        Returns
        -------
        list
            Returns list of action rules.
        &#34;&#34;&#34;
        if len(self.action_rules.action_rules_pretty_text) == 0:
            self.action_rules.pretty_text()
        return self.action_rules.action_rules_pretty_text

    def get_action_rules_representation(self) -&gt; list:
        &#34;&#34;&#34;Get math representation of action rules.

        Returns
        -------
        list
            Returns list of action rules.
        &#34;&#34;&#34;
        if len(self.action_rules.action_rules_representation) == 0:
            self.action_rules.representation()
        return self.action_rules.action_rules_representation

    def get_source_data_for_ar(self, action_r_number: int, is_before: bool) -&gt; pd.DataFrame:
        &#34;&#34;&#34; Get data frame with values which the action rule is based on.

        Yellow background - stable attributes
        Orange background - flexible attributes
        Red text - Target attribute, undesired state
        Green text - Target attribute, desired state

        Parameters
        ----------
        action_r_number : int
            The number of action rule - you can figure out from get_action_rules
        is_before : bool
            True shows instances in data that match the conditions of the &#34;before&#34; part of the action rule.
            False show instances in data that match the conditions of the &#34;after&#34; part of the action rule.

        Returns
        -------
        pd.DataFrame
            Returns data frame with transactions data.
        &#34;&#34;&#34;
        if is_before:
            classification = self.action_rules.classification_before[action_r_number]
        else:
            classification = self.action_rules.classification_after[action_r_number]
        decision = self.decisions.decision_table.loc[
            classification, self.stable_attributes + self.flexible_attributes]
        source_table = self._reduce_table_source(decision, self.decisions.data)
        return source_table.style.applymap(lambda x: &#39;background-color: yellow&#39;,
                                           subset=self.stable_attributes) \
            .applymap(lambda x: &#39;background-color: orange&#39;,
                      subset=self.flexible_attributes) \
            .applymap(lambda x: &#39;color: green&#39; if x in self.desired_state.get_destination_classes() else &#39;color: red&#39;,
                      subset=[self.consequent])

    @staticmethod
    def _reduce_table_source(decision: pd.Series, source_table: pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34; Get data frame limited by concrete classification rule.

        Parameters
        ----------
        decision : pd.Series
            A classification rule.
        source_table : pd.DataFrame
            A source data frame.

        Returns
        -------
        pd.DataFrame
            Returns a limited data frame.
        &#34;&#34;&#34;
        new_data = source_table.applymap(str).copy()
        for key, value in decision.items():
            if str(value) != &#34;nan&#34;:
                mask = new_data[key] == value
                new_data = new_data[mask]
        return new_data

    def predict(self, source_table: pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34; Predicts if any values would need to change their state.

        Parameters
        ----------
        source_table : pd.DataFrame
            A data frame with new observations.

        Returns
        -------
        pd.DataFrame
            Returns a data frame with recommended actions.
        &#34;&#34;&#34;
        i = 0
        full_predicted_table = pd.DataFrame()
        for classification_before in self.action_rules.classification_before:
            classification_after = self.action_rules.classification_after[i]
            decision_before = self.decisions.decision_table.loc[
                classification_before, self.stable_attributes + self.flexible_attributes]
            decision_after = self.decisions.decision_table.loc[
                classification_after, self.stable_attributes + self.flexible_attributes]
            predicted_table = self._reduce_table_source(decision_before, source_table)
            if len(predicted_table.index) &gt; 0:
                for key, value in decision_after.items():
                    if str(value) != &#34;nan&#34; and key in self.flexible_attributes:
                        column = key + self.RECOMMENDED
                        predicted_table[column] = [value] * len(predicted_table.index)
                        predicted_table[self.ACTION_RULE] = [i] * len(predicted_table.index)
                        predicted_table = predicted_table.astype({self.ACTION_RULE: int})
                predicted_table[self.ACTION_RULE_TARGET] = \
                    [self.action_rules.action_rules[i][0][2][1][1]] * len(predicted_table.index)
                predicted_table[self.SUPPORT_BEFORE] = \
                    [self.action_rules.action_rules[i][1][0]] * len(predicted_table.index)
                predicted_table[self.SUPPORT_AFTER] = \
                    [self.action_rules.action_rules[i][1][1]] * len(predicted_table.index)
                predicted_table[self.ACTION_RULE_SUPPORT] = \
                    [self.action_rules.action_rules[i][1][2]] * len(predicted_table.index)
                predicted_table[self.CONFIDENCE_BEFORE] = \
                    [self.action_rules.action_rules[i][2][0]] * len(predicted_table.index)
                predicted_table[self.CONFIDENCE_AFTER] = \
                    [self.action_rules.action_rules[i][2][1]] * len(predicted_table.index)
                predicted_table[self.ACTION_RULE_CONFIDENCE] = \
                    [self.action_rules.action_rules[i][2][2]] * len(predicted_table.index)
                predicted_table[self.ACTION_RULE_UPLIFT] = \
                    [self.action_rules.action_rules[i][3]] * len(predicted_table.index)
            full_predicted_table = pd.concat([full_predicted_table, predicted_table], sort=True)
            i += 1
        # New columns always in the end
        cols = full_predicted_table.columns.tolist()
        if len(cols)&gt;0:
            cols.append(cols.pop(cols.index(self.ACTION_RULE)))
            cols.append(cols.pop(cols.index(self.ACTION_RULE_TARGET)))
            cols.append(cols.pop(cols.index(self.SUPPORT_BEFORE)))
            cols.append(cols.pop(cols.index(self.SUPPORT_AFTER)))
            cols.append(cols.pop(cols.index(self.ACTION_RULE_SUPPORT)))
            cols.append(cols.pop(cols.index(self.CONFIDENCE_BEFORE)))
            cols.append(cols.pop(cols.index(self.CONFIDENCE_AFTER)))
            cols.append(cols.pop(cols.index(self.ACTION_RULE_CONFIDENCE)))
            cols.append(cols.pop(cols.index(self.ACTION_RULE_UPLIFT)))
            full_predicted_table = full_predicted_table[cols]
        return full_predicted_table</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery"><code class="flex name class">
<span>class <span class="ident">ActionRulesDiscovery</span></span>
</code></dt>
<dd>
<section class="desc"><p>The class ActionRulesDiscovery is the main control class where the methods fit or
predict can be called. However, there is a minimum logic in the class. It is just an
interface that initializes other objects and calls their methods.</p>
<p>&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>decisions</code></strong> :&ensp;<code>Decisions</code>()</dt>
<dd>Object that runs PyFIM classification rules discovery.</dd>
<dt><strong><code>action_rules</code></strong> :&ensp;<code>None</code> or <code>ActionRules</code></dt>
<dd>Object that runs action rules discovery.</dd>
<dt><strong><code>desired_state</code></strong> :&ensp;<code>DesiredState</code></dt>
<dd>Object that is responsible for handling of desired state.</dd>
<dt><strong><code>stable_attributes</code></strong> :&ensp;<code>list</code></dt>
<dd>List of stable attributes.</dd>
<dt><strong><code>flexible_attributes</code></strong> :&ensp;<code>list</code></dt>
<dd>List of flexible attributes.</dd>
<dt><strong><code>consequent</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of consequent columns.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>read_csv(self, file: str, **kwargs)
Import data from a CSV file.
load_pandas(self, data_frame: pd.DataFrame)
Import data from Pandas data frame.
fit(self,
stable_attributes: List[str],
flexible_attributes: List[str],
consequent: str,
conf: float,
supp: float,
desired_classes: List[str] = None,
desired_changes: List[list] = None,
is_nan: bool = False,
is_reduction: bool = True,
min_stable_attributes: int = 1,
min_flexible_attributes: int = 1,
max_stable_attributes: int = 5,
max_flexible_attributes: int = 5,
)
Train the model from transaction data.
fit_classification_rules(self,
stable_attributes: List[str],
flexible_attributes: List[str],
consequent: str,
conf_col: str,
supp_col: str,
desired_classes: List[str] = None,
desired_changes: List[list] = None,
is_nan: bool = False,
is_reduction: bool = True,
min_stable_attributes: int = 1,
min_flexible_attributes: int = 1,
max_stable_attributes: int = 5,
max_flexible_attributes: int = 5,
)
Train the model from classification rules.
get_action_rules(self) -&gt; list
Get list of action rules (machine representation)
get_pretty_action_rules(self) -&gt; list
Get human-readable representations of action rules
get_action_rules_representation(self) -&gt; list
Get math representation of action rules
get_source_data_for_ar(self, action_r_number: int, is_before: bool) -&gt; pd.DataFrame
Get the source data the action rule is discovered from.
predict(self, source_table: pd.DataFrame) -&gt; pd.DataFrame
Predicts if new occurrence would need any change.</p>
<dl>
<dt><strong><code>Initialise</code></strong></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ActionRulesDiscovery:
    &#34;&#34;&#34;
    The class ActionRulesDiscovery is the main control class where the methods fit or
    predict can be called. However, there is a minimum logic in the class. It is just an
    interface that initializes other objects and calls their methods.

    ...

    Attributes
    ----------
    decisions : Decisions()
        Object that runs PyFIM classification rules discovery.
    action_rules: None or ActionRules
        Object that runs action rules discovery.
    desired_state: DesiredState
        Object that is responsible for handling of desired state.
    stable_attributes: list
        List of stable attributes.
    flexible_attributes: list
        List of flexible attributes.
    consequent: str
        Name of consequent columns.

    Methods
    -------
    read_csv(self, file: str, **kwargs)
        Import data from a CSV file.
    load_pandas(self, data_frame: pd.DataFrame)
        Import data from Pandas data frame.
    fit(self,
        stable_attributes: List[str],
        flexible_attributes: List[str],
        consequent: str,
        conf: float,
        supp: float,
        desired_classes: List[str] = None,
        desired_changes: List[list] = None,
        is_nan: bool = False,
        is_reduction: bool = True,
        min_stable_attributes: int = 1,
        min_flexible_attributes: int = 1,
        max_stable_attributes: int = 5,
        max_flexible_attributes: int = 5,
        )
        Train the model from transaction data.
    fit_classification_rules(self,
                             stable_attributes: List[str],
                             flexible_attributes: List[str],
                             consequent: str,
                             conf_col: str,
                             supp_col: str,
                             desired_classes: List[str] = None,
                             desired_changes: List[list] = None,
                             is_nan: bool = False,
                             is_reduction: bool = True,
                             min_stable_attributes: int = 1,
                             min_flexible_attributes: int = 1,
                             max_stable_attributes: int = 5,
                             max_flexible_attributes: int = 5,
                             )
        Train the model from classification rules.
    get_action_rules(self) -&gt; list
        Get list of action rules (machine representation)
    get_pretty_action_rules(self) -&gt; list
        Get human-readable representations of action rules
    get_action_rules_representation(self) -&gt; list
        Get math representation of action rules
    get_source_data_for_ar(self, action_r_number: int, is_before: bool) -&gt; pd.DataFrame
        Get the source data the action rule is discovered from.
    predict(self, source_table: pd.DataFrame) -&gt; pd.DataFrame
        Predicts if new occurrence would need any change.

    &#34;&#34;&#34;
    ACTION_RULE = &#34;action rule&#34;
    ACTION_RULE_TARGET = &#34;action rule target&#34;
    SUPPORT_BEFORE = &#34;support before&#34;
    SUPPORT_AFTER = &#34;support after&#34;
    ACTION_RULE_SUPPORT = &#34;action rule support&#34;
    CONFIDENCE_BEFORE = &#34;confidence before&#34;
    CONFIDENCE_AFTER = &#34;confidence after&#34;
    ACTION_RULE_CONFIDENCE = &#34;action rule confidence&#34;
    ACTION_RULE_UPLIFT = &#34;uplift&#34;
    RECOMMENDED = &#34;-recommended&#34;

    def __init__(self):
        &#34;&#34;&#34;
        Initialise
        &#34;&#34;&#34;
        self.decisions = Decisions()
        self.action_rules = None
        self.desired_state = None
        self.stable_attributes = []
        self.flexible_attributes = []
        self.consequent = &#34;&#34;

    def _check_columns(self, attributes: List[str], consequent: str):
        &#34;&#34;&#34;Checks if inserted data is valid (columns exist, rows exist).

        Parameters
        ----------
        attributes : List[str]
            List of attributes names.
        consequent : str
            The name of consequent.

        Raises
        ------
        Exception
            If no data entered or column does not exist in data.
        &#34;&#34;&#34;
        if len(self.decisions.data) == 0:
            raise Exception(&#34;No data entered.&#34;)
        columns = self.decisions.data.columns
        for col_name in attributes + [consequent]:
            if col_name not in columns:
                raise Exception(&#34;Column &#34; + str(col_name) + &#34; does not exist in data&#34;)

    def read_csv(self, file: str, **kwargs):
        &#34;&#34;&#34;Imports data from a CSV file.

        It uses the same optional parameters as read_csv from Pandas.

        Parameters
        ----------
        file : str
            A path to a file.
        **kwargs :
            Arbitrary keyword arguments (the same as in Pandas).
        &#34;&#34;&#34;
        self.decisions.read_csv(file, **kwargs)

    def load_pandas(self, data_frame: pd.DataFrame):
        &#34;&#34;&#34;Loads a data frame.

        It must be the Pandas data frame.

        Parameters
        ----------
        data_frame : pd.DataFrame
            Pandas data frame.
        &#34;&#34;&#34;
        self.decisions.load_pandas(data_frame)

    def fit(self,
            stable_attributes: List[str],
            flexible_attributes: List[str],
            consequent: str,
            conf: float,
            supp: float,
            desired_classes: List[str] = None,
            desired_changes: List[list] = None,
            is_nan: bool = False,
            is_reduction: bool = True,
            min_stable_attributes: int = 1,
            min_flexible_attributes: int = 1,
            max_stable_attributes: int = 5,
            max_flexible_attributes: int = 5,
            ):
        &#34;&#34;&#34;Train the model from transaction data.

        Define antecedent and consequent.
        - stable_attributes
        - flexible_attributes
        - consequent
        Confidence and support.
        - conf
        - supp
        Desired classes or desired changes must be entered.
        - desired_classes
        - desired_changes
        Should NaN values be used?
        - is_nan
        Should the reduction table be used?
        - is_reduction
        Minimal number of stable and flexible pairs in antecedent.
        - min_stable_attributes
        - min_flexible_attributes
        - max_stable_attributes
        - max_flexible_attributes

        Parameters
        ----------
        stable_attributes : List[str]
            List of column names.
        flexible_attributes : List[str]
            List of column names.
        consequent : str
            Name of the consequent column.
        conf : float
            Value in % for minimal confidence in classification rules.
            For example, 60.
        supp : float
            Value in % for minimal support of classification rules.
            For example, 5.
        desired_classes : List[str] = None
            List of decision states. For example, [&#34;1&#34;].
            DEFAULT: None
        desired_changes : List[list] = None
            List of desired changes. For example, [[&#34;0&#34;, &#34;1&#34;]].
            DEFAULT: None
        is_nan : bool = False
            True means NaN values are used, False means NaN values are not used.
            It means NaN values from classification rules.
            DEFAULT: FALSE
        is_reduction : bool = True
            Is the reduction table used?
            DEFAULT: TRUE
        min_stable_attributes : int = 1
            Minimal number of stable pairs.
            DEFAULT: 1
        min_flexible_attributes : int = 1
            Minimal number of flexible pairs.
            DEFAULT: 1
        max_stable_attributes : int = 5
            Maximal number of stable pairs.
            DEFAULT: 5
        max_flexible_attributes : int = 5
            Maximal number of flexible pairs.
            DEFAULT: 5
        &#34;&#34;&#34;
        if (self.action_rules):
            raise Exception(&#34;Fit was already called&#34;)
        self.stable_attributes = stable_attributes
        self.flexible_attributes = flexible_attributes
        self.consequent = consequent
        if bool(desired_classes) != bool(desired_changes):
            self.desired_state = DesiredState(desired_classes=desired_classes, desired_changes=desired_changes)
        else:
            raise Exception(&#34;Desired classes or desired changes must be entered&#34;)
        attributes = stable_attributes + flexible_attributes
        self._check_columns(attributes, consequent)
        self.decisions.prepare_data_fim(attributes, consequent)
        self.decisions.fit_fim_apriori(conf=conf, support=supp)
        self.decisions.generate_decision_table()
        stable = self.decisions.decision_table[stable_attributes]
        flex = self.decisions.decision_table[flexible_attributes]
        target = self.decisions.decision_table[[consequent]]
        supp = self.decisions.support
        conf = self.decisions.confidence
        reduced_tables = Reduction(stable, flex, target, self.desired_state, supp, conf, is_nan)
        if is_reduction:
            reduced_tables.reduce()
        self.action_rules = ActionRules(
            reduced_tables.stable_tables,
            reduced_tables.flexible_tables,
            reduced_tables.decision_tables,
            self.desired_state,
            reduced_tables.supp,
            reduced_tables.conf,
            is_nan,
            min_stable_attributes,
            min_flexible_attributes,
            max_stable_attributes,
            max_flexible_attributes
        )
        self.action_rules.fit()

    def fit_classification_rules(self,
                                 stable_attributes: List[str],
                                 flexible_attributes: List[str],
                                 consequent: str,
                                 conf_col: str,
                                 supp_col: str,
                                 desired_classes: List[str] = None,
                                 desired_changes: List[list] = None,
                                 is_nan: bool = False,
                                 is_reduction: bool = True,
                                 min_stable_attributes: int = 1,
                                 min_flexible_attributes: int = 1,
                                 max_stable_attributes: int = 5,
                                 max_flexible_attributes: int = 5,
                                 ):
        &#34;&#34;&#34;Train the model from classification rules.

        Define antecedent and consequent.
        - stable_attributes
        - flexible_attributes
        - consequent
        Confidence and support.
        - conf_col
        - supp_col
        Desired classes or desired changes must be entered.
        - desired_classes
        - desired_changes
        Should NaN values be used?
        - is_nan
        Should the reduction table be used?
        - is_reduction
        Minimal number of stable and flexible pairs in antecedent.
        - min_stable_attributes
        - min_flexible_attributes
        - max_stable_attributes
        - max_flexible_attributes

        Parameters
        ----------
        stable_attributes: List[str]
            List of column names.
        flexible_attributes: List[str]
            List of column names.
        consequent: str
            Name of the consequent column.
        conf_col: str
            Name of the column with classification rule confidence -
            the numbers should be in form 0.1 for 10%.
        supp_col: str
            Name of the column with classification rule support -
            the numbers should be in form 0.1 for 10%.
        desired_classes: List[str] = None
            List of decision states. For example [&#34;1&#34;].
            DEFAULT: None
        desired_changes: List[list] = None
            List of desired changes. For example [[&#34;0&#34;, &#34;1&#34;]].
            DEFAULT: None
        is_nan: bool = False
            True means NaN values are used, False means nan values are not used.
            DEFAULT: FALSE
        is_reduction: bool = True
            Is the reduction table used?
            DEFAULT: TRUE
        min_stable_attributes: int = 1
            Minimal number of stable pairs.
            DEFAULT: 1
        min_flexible_attributes: int = 1
            Minimal number of flexible pairs.
            DEFAULT: 1
        max_stable_attributes: int = 5
            Maximal number of stable pairs.
            DEFAULT: 5
        max_flexible_attributes: int = 5
            Maximal number of flexible pairs.
            DEFAULT: 5
        &#34;&#34;&#34;
        if (self.action_rules):
            raise Exception(&#34;Fit was already called&#34;)
        self.stable_attributes = stable_attributes
        self.flexible_attributes = flexible_attributes
        self.consequent = consequent
        if bool(desired_classes) != bool(desired_changes):
            self.desired_state = DesiredState(desired_classes=desired_classes, desired_changes=desired_changes)
        else:
            raise Exception(&#34;Desired classes or desired changes must be entered&#34;)
        attributes = stable_attributes + flexible_attributes
        self._check_columns(attributes, consequent)
        stable = self.decisions.data[stable_attributes]
        flex = self.decisions.data[flexible_attributes]
        target = self.decisions.data[[consequent]]
        supp_df = self.decisions.data[[supp_col]]
        supp_series = supp_df.iloc[:, 0]
        supp = supp_series.tolist()
        conf_df = self.decisions.data[[conf_col]]
        conf_series = conf_df.iloc[:, 0]
        conf = conf_series.tolist()
        reduced_tables = Reduction(stable, flex, target, self.desired_state, supp, conf, is_nan)
        if is_reduction:
            reduced_tables.reduce()
        self.action_rules = ActionRules(
            reduced_tables.stable_tables,
            reduced_tables.flexible_tables,
            reduced_tables.decision_tables,
            self.desired_state,
            reduced_tables.supp,
            reduced_tables.conf,
            is_nan,
            min_stable_attributes,
            min_flexible_attributes,
            max_stable_attributes,
            max_flexible_attributes
        )
        self.action_rules.fit()

    def get_action_rules(self) -&gt; list:
        &#34;&#34;&#34;Get machine representations of action rules.

        The output is a list of action
        rules. Each action rule is a list where the first part is an action rule itself, and the second part is
        a tuple of (support before, support after, action rule support), (confidence before, confidence after, action
        rule confidence) and uplift.

        Returns
        -------
        list
            Returns list of action rules.
        &#34;&#34;&#34;
        return self.action_rules.action_rules

    def get_pretty_action_rules(self) -&gt; list:
        &#34;&#34;&#34;Get human-readable representations of action rules.

        Returns
        -------
        list
            Returns list of action rules.
        &#34;&#34;&#34;
        if len(self.action_rules.action_rules_pretty_text) == 0:
            self.action_rules.pretty_text()
        return self.action_rules.action_rules_pretty_text

    def get_action_rules_representation(self) -&gt; list:
        &#34;&#34;&#34;Get math representation of action rules.

        Returns
        -------
        list
            Returns list of action rules.
        &#34;&#34;&#34;
        if len(self.action_rules.action_rules_representation) == 0:
            self.action_rules.representation()
        return self.action_rules.action_rules_representation

    def get_source_data_for_ar(self, action_r_number: int, is_before: bool) -&gt; pd.DataFrame:
        &#34;&#34;&#34; Get data frame with values which the action rule is based on.

        Yellow background - stable attributes
        Orange background - flexible attributes
        Red text - Target attribute, undesired state
        Green text - Target attribute, desired state

        Parameters
        ----------
        action_r_number : int
            The number of action rule - you can figure out from get_action_rules
        is_before : bool
            True shows instances in data that match the conditions of the &#34;before&#34; part of the action rule.
            False show instances in data that match the conditions of the &#34;after&#34; part of the action rule.

        Returns
        -------
        pd.DataFrame
            Returns data frame with transactions data.
        &#34;&#34;&#34;
        if is_before:
            classification = self.action_rules.classification_before[action_r_number]
        else:
            classification = self.action_rules.classification_after[action_r_number]
        decision = self.decisions.decision_table.loc[
            classification, self.stable_attributes + self.flexible_attributes]
        source_table = self._reduce_table_source(decision, self.decisions.data)
        return source_table.style.applymap(lambda x: &#39;background-color: yellow&#39;,
                                           subset=self.stable_attributes) \
            .applymap(lambda x: &#39;background-color: orange&#39;,
                      subset=self.flexible_attributes) \
            .applymap(lambda x: &#39;color: green&#39; if x in self.desired_state.get_destination_classes() else &#39;color: red&#39;,
                      subset=[self.consequent])

    @staticmethod
    def _reduce_table_source(decision: pd.Series, source_table: pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34; Get data frame limited by concrete classification rule.

        Parameters
        ----------
        decision : pd.Series
            A classification rule.
        source_table : pd.DataFrame
            A source data frame.

        Returns
        -------
        pd.DataFrame
            Returns a limited data frame.
        &#34;&#34;&#34;
        new_data = source_table.applymap(str).copy()
        for key, value in decision.items():
            if str(value) != &#34;nan&#34;:
                mask = new_data[key] == value
                new_data = new_data[mask]
        return new_data

    def predict(self, source_table: pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34; Predicts if any values would need to change their state.

        Parameters
        ----------
        source_table : pd.DataFrame
            A data frame with new observations.

        Returns
        -------
        pd.DataFrame
            Returns a data frame with recommended actions.
        &#34;&#34;&#34;
        i = 0
        full_predicted_table = pd.DataFrame()
        for classification_before in self.action_rules.classification_before:
            classification_after = self.action_rules.classification_after[i]
            decision_before = self.decisions.decision_table.loc[
                classification_before, self.stable_attributes + self.flexible_attributes]
            decision_after = self.decisions.decision_table.loc[
                classification_after, self.stable_attributes + self.flexible_attributes]
            predicted_table = self._reduce_table_source(decision_before, source_table)
            if len(predicted_table.index) &gt; 0:
                for key, value in decision_after.items():
                    if str(value) != &#34;nan&#34; and key in self.flexible_attributes:
                        column = key + self.RECOMMENDED
                        predicted_table[column] = [value] * len(predicted_table.index)
                        predicted_table[self.ACTION_RULE] = [i] * len(predicted_table.index)
                        predicted_table = predicted_table.astype({self.ACTION_RULE: int})
                predicted_table[self.ACTION_RULE_TARGET] = \
                    [self.action_rules.action_rules[i][0][2][1][1]] * len(predicted_table.index)
                predicted_table[self.SUPPORT_BEFORE] = \
                    [self.action_rules.action_rules[i][1][0]] * len(predicted_table.index)
                predicted_table[self.SUPPORT_AFTER] = \
                    [self.action_rules.action_rules[i][1][1]] * len(predicted_table.index)
                predicted_table[self.ACTION_RULE_SUPPORT] = \
                    [self.action_rules.action_rules[i][1][2]] * len(predicted_table.index)
                predicted_table[self.CONFIDENCE_BEFORE] = \
                    [self.action_rules.action_rules[i][2][0]] * len(predicted_table.index)
                predicted_table[self.CONFIDENCE_AFTER] = \
                    [self.action_rules.action_rules[i][2][1]] * len(predicted_table.index)
                predicted_table[self.ACTION_RULE_CONFIDENCE] = \
                    [self.action_rules.action_rules[i][2][2]] * len(predicted_table.index)
                predicted_table[self.ACTION_RULE_UPLIFT] = \
                    [self.action_rules.action_rules[i][3]] * len(predicted_table.index)
            full_predicted_table = pd.concat([full_predicted_table, predicted_table], sort=True)
            i += 1
        # New columns always in the end
        cols = full_predicted_table.columns.tolist()
        if len(cols)&gt;0:
            cols.append(cols.pop(cols.index(self.ACTION_RULE)))
            cols.append(cols.pop(cols.index(self.ACTION_RULE_TARGET)))
            cols.append(cols.pop(cols.index(self.SUPPORT_BEFORE)))
            cols.append(cols.pop(cols.index(self.SUPPORT_AFTER)))
            cols.append(cols.pop(cols.index(self.ACTION_RULE_SUPPORT)))
            cols.append(cols.pop(cols.index(self.CONFIDENCE_BEFORE)))
            cols.append(cols.pop(cols.index(self.CONFIDENCE_AFTER)))
            cols.append(cols.pop(cols.index(self.ACTION_RULE_CONFIDENCE)))
            cols.append(cols.pop(cols.index(self.ACTION_RULE_UPLIFT)))
            full_predicted_table = full_predicted_table[cols]
        return full_predicted_table</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.ACTION_RULE"><code class="name">var <span class="ident">ACTION_RULE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.ACTION_RULE_CONFIDENCE"><code class="name">var <span class="ident">ACTION_RULE_CONFIDENCE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.ACTION_RULE_SUPPORT"><code class="name">var <span class="ident">ACTION_RULE_SUPPORT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.ACTION_RULE_TARGET"><code class="name">var <span class="ident">ACTION_RULE_TARGET</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.ACTION_RULE_UPLIFT"><code class="name">var <span class="ident">ACTION_RULE_UPLIFT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.CONFIDENCE_AFTER"><code class="name">var <span class="ident">CONFIDENCE_AFTER</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.CONFIDENCE_BEFORE"><code class="name">var <span class="ident">CONFIDENCE_BEFORE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.RECOMMENDED"><code class="name">var <span class="ident">RECOMMENDED</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.SUPPORT_AFTER"><code class="name">var <span class="ident">SUPPORT_AFTER</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.SUPPORT_BEFORE"><code class="name">var <span class="ident">SUPPORT_BEFORE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, stable_attributes, flexible_attributes, consequent, conf, supp, desired_classes=None, desired_changes=None, is_nan=False, is_reduction=True, min_stable_attributes=1, min_flexible_attributes=1, max_stable_attributes=5, max_flexible_attributes=5)</span>
</code></dt>
<dd>
<section class="desc"><p>Train the model from transaction data.</p>
<p>Define antecedent and consequent.
- stable_attributes
- flexible_attributes
- consequent
Confidence and support.
- conf
- supp
Desired classes or desired changes must be entered.
- desired_classes
- desired_changes
Should NaN values be used?
- is_nan
Should the reduction table be used?
- is_reduction
Minimal number of stable and flexible pairs in antecedent.
- min_stable_attributes
- min_flexible_attributes
- max_stable_attributes
- max_flexible_attributes</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stable_attributes</code></strong> :&ensp;<code>List</code>[<code>str</code>]</dt>
<dd>List of column names.</dd>
<dt><strong><code>flexible_attributes</code></strong> :&ensp;<code>List</code>[<code>str</code>]</dt>
<dd>List of column names.</dd>
<dt><strong><code>consequent</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the consequent column.</dd>
<dt><strong><code>conf</code></strong> :&ensp;<code>float</code></dt>
<dd>Value in % for minimal confidence in classification rules.
For example, 60.</dd>
<dt><strong><code>supp</code></strong> :&ensp;<code>float</code></dt>
<dd>Value in % for minimal support of classification rules.
For example, 5.</dd>
<dt><strong><code>desired_classes</code></strong> :&ensp;<code>List</code>[<code>str</code>] = <code>None</code></dt>
<dd>List of decision states. For example, ["1"].
DEFAULT: None</dd>
<dt><strong><code>desired_changes</code></strong> :&ensp;<code>List</code>[<code>list</code>] = <code>None</code></dt>
<dd>List of desired changes. For example, [["0", "1"]].
DEFAULT: None</dd>
<dt><strong><code>is_nan</code></strong> :&ensp;<code>bool</code> = <code>False</code></dt>
<dd>True means NaN values are used, False means NaN values are not used.
It means NaN values from classification rules.
DEFAULT: FALSE</dd>
<dt><strong><code>is_reduction</code></strong> :&ensp;<code>bool</code> = <code>True</code></dt>
<dd>Is the reduction table used?
DEFAULT: TRUE</dd>
<dt><strong><code>min_stable_attributes</code></strong> :&ensp;<code>int</code> = <code>1</code></dt>
<dd>Minimal number of stable pairs.
DEFAULT: 1</dd>
<dt><strong><code>min_flexible_attributes</code></strong> :&ensp;<code>int</code> = <code>1</code></dt>
<dd>Minimal number of flexible pairs.
DEFAULT: 1</dd>
<dt><strong><code>max_stable_attributes</code></strong> :&ensp;<code>int</code> = <code>5</code></dt>
<dd>Maximal number of stable pairs.
DEFAULT: 5</dd>
<dt><strong><code>max_flexible_attributes</code></strong> :&ensp;<code>int</code> = <code>5</code></dt>
<dd>Maximal number of flexible pairs.
DEFAULT: 5</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(self,
        stable_attributes: List[str],
        flexible_attributes: List[str],
        consequent: str,
        conf: float,
        supp: float,
        desired_classes: List[str] = None,
        desired_changes: List[list] = None,
        is_nan: bool = False,
        is_reduction: bool = True,
        min_stable_attributes: int = 1,
        min_flexible_attributes: int = 1,
        max_stable_attributes: int = 5,
        max_flexible_attributes: int = 5,
        ):
    &#34;&#34;&#34;Train the model from transaction data.

    Define antecedent and consequent.
    - stable_attributes
    - flexible_attributes
    - consequent
    Confidence and support.
    - conf
    - supp
    Desired classes or desired changes must be entered.
    - desired_classes
    - desired_changes
    Should NaN values be used?
    - is_nan
    Should the reduction table be used?
    - is_reduction
    Minimal number of stable and flexible pairs in antecedent.
    - min_stable_attributes
    - min_flexible_attributes
    - max_stable_attributes
    - max_flexible_attributes

    Parameters
    ----------
    stable_attributes : List[str]
        List of column names.
    flexible_attributes : List[str]
        List of column names.
    consequent : str
        Name of the consequent column.
    conf : float
        Value in % for minimal confidence in classification rules.
        For example, 60.
    supp : float
        Value in % for minimal support of classification rules.
        For example, 5.
    desired_classes : List[str] = None
        List of decision states. For example, [&#34;1&#34;].
        DEFAULT: None
    desired_changes : List[list] = None
        List of desired changes. For example, [[&#34;0&#34;, &#34;1&#34;]].
        DEFAULT: None
    is_nan : bool = False
        True means NaN values are used, False means NaN values are not used.
        It means NaN values from classification rules.
        DEFAULT: FALSE
    is_reduction : bool = True
        Is the reduction table used?
        DEFAULT: TRUE
    min_stable_attributes : int = 1
        Minimal number of stable pairs.
        DEFAULT: 1
    min_flexible_attributes : int = 1
        Minimal number of flexible pairs.
        DEFAULT: 1
    max_stable_attributes : int = 5
        Maximal number of stable pairs.
        DEFAULT: 5
    max_flexible_attributes : int = 5
        Maximal number of flexible pairs.
        DEFAULT: 5
    &#34;&#34;&#34;
    if (self.action_rules):
        raise Exception(&#34;Fit was already called&#34;)
    self.stable_attributes = stable_attributes
    self.flexible_attributes = flexible_attributes
    self.consequent = consequent
    if bool(desired_classes) != bool(desired_changes):
        self.desired_state = DesiredState(desired_classes=desired_classes, desired_changes=desired_changes)
    else:
        raise Exception(&#34;Desired classes or desired changes must be entered&#34;)
    attributes = stable_attributes + flexible_attributes
    self._check_columns(attributes, consequent)
    self.decisions.prepare_data_fim(attributes, consequent)
    self.decisions.fit_fim_apriori(conf=conf, support=supp)
    self.decisions.generate_decision_table()
    stable = self.decisions.decision_table[stable_attributes]
    flex = self.decisions.decision_table[flexible_attributes]
    target = self.decisions.decision_table[[consequent]]
    supp = self.decisions.support
    conf = self.decisions.confidence
    reduced_tables = Reduction(stable, flex, target, self.desired_state, supp, conf, is_nan)
    if is_reduction:
        reduced_tables.reduce()
    self.action_rules = ActionRules(
        reduced_tables.stable_tables,
        reduced_tables.flexible_tables,
        reduced_tables.decision_tables,
        self.desired_state,
        reduced_tables.supp,
        reduced_tables.conf,
        is_nan,
        min_stable_attributes,
        min_flexible_attributes,
        max_stable_attributes,
        max_flexible_attributes
    )
    self.action_rules.fit()</code></pre>
</details>
</dd>
<dt id="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.fit_classification_rules"><code class="name flex">
<span>def <span class="ident">fit_classification_rules</span></span>(<span>self, stable_attributes, flexible_attributes, consequent, conf_col, supp_col, desired_classes=None, desired_changes=None, is_nan=False, is_reduction=True, min_stable_attributes=1, min_flexible_attributes=1, max_stable_attributes=5, max_flexible_attributes=5)</span>
</code></dt>
<dd>
<section class="desc"><p>Train the model from classification rules.</p>
<p>Define antecedent and consequent.
- stable_attributes
- flexible_attributes
- consequent
Confidence and support.
- conf_col
- supp_col
Desired classes or desired changes must be entered.
- desired_classes
- desired_changes
Should NaN values be used?
- is_nan
Should the reduction table be used?
- is_reduction
Minimal number of stable and flexible pairs in antecedent.
- min_stable_attributes
- min_flexible_attributes
- max_stable_attributes
- max_flexible_attributes</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stable_attributes</code></strong> :&ensp;<code>List</code>[<code>str</code>]</dt>
<dd>List of column names.</dd>
<dt><strong><code>flexible_attributes</code></strong> :&ensp;<code>List</code>[<code>str</code>]</dt>
<dd>List of column names.</dd>
<dt><strong><code>consequent</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the consequent column.</dd>
<dt><strong><code>conf_col</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the column with classification rule confidence -
the numbers should be in form 0.1 for 10%.</dd>
<dt><strong><code>supp_col</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the column with classification rule support -
the numbers should be in form 0.1 for 10%.</dd>
<dt><strong><code>desired_classes</code></strong> :&ensp;<code>List</code>[<code>str</code>] = <code>None</code></dt>
<dd>List of decision states. For example ["1"].
DEFAULT: None</dd>
<dt><strong><code>desired_changes</code></strong> :&ensp;<code>List</code>[<code>list</code>] = <code>None</code></dt>
<dd>List of desired changes. For example [["0", "1"]].
DEFAULT: None</dd>
<dt><strong><code>is_nan</code></strong> :&ensp;<code>bool</code> = <code>False</code></dt>
<dd>True means NaN values are used, False means nan values are not used.
DEFAULT: FALSE</dd>
<dt><strong><code>is_reduction</code></strong> :&ensp;<code>bool</code> = <code>True</code></dt>
<dd>Is the reduction table used?
DEFAULT: TRUE</dd>
<dt><strong><code>min_stable_attributes</code></strong> :&ensp;<code>int</code> = <code>1</code></dt>
<dd>Minimal number of stable pairs.
DEFAULT: 1</dd>
<dt><strong><code>min_flexible_attributes</code></strong> :&ensp;<code>int</code> = <code>1</code></dt>
<dd>Minimal number of flexible pairs.
DEFAULT: 1</dd>
<dt><strong><code>max_stable_attributes</code></strong> :&ensp;<code>int</code> = <code>5</code></dt>
<dd>Maximal number of stable pairs.
DEFAULT: 5</dd>
<dt><strong><code>max_flexible_attributes</code></strong> :&ensp;<code>int</code> = <code>5</code></dt>
<dd>Maximal number of flexible pairs.
DEFAULT: 5</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_classification_rules(self,
                             stable_attributes: List[str],
                             flexible_attributes: List[str],
                             consequent: str,
                             conf_col: str,
                             supp_col: str,
                             desired_classes: List[str] = None,
                             desired_changes: List[list] = None,
                             is_nan: bool = False,
                             is_reduction: bool = True,
                             min_stable_attributes: int = 1,
                             min_flexible_attributes: int = 1,
                             max_stable_attributes: int = 5,
                             max_flexible_attributes: int = 5,
                             ):
    &#34;&#34;&#34;Train the model from classification rules.

    Define antecedent and consequent.
    - stable_attributes
    - flexible_attributes
    - consequent
    Confidence and support.
    - conf_col
    - supp_col
    Desired classes or desired changes must be entered.
    - desired_classes
    - desired_changes
    Should NaN values be used?
    - is_nan
    Should the reduction table be used?
    - is_reduction
    Minimal number of stable and flexible pairs in antecedent.
    - min_stable_attributes
    - min_flexible_attributes
    - max_stable_attributes
    - max_flexible_attributes

    Parameters
    ----------
    stable_attributes: List[str]
        List of column names.
    flexible_attributes: List[str]
        List of column names.
    consequent: str
        Name of the consequent column.
    conf_col: str
        Name of the column with classification rule confidence -
        the numbers should be in form 0.1 for 10%.
    supp_col: str
        Name of the column with classification rule support -
        the numbers should be in form 0.1 for 10%.
    desired_classes: List[str] = None
        List of decision states. For example [&#34;1&#34;].
        DEFAULT: None
    desired_changes: List[list] = None
        List of desired changes. For example [[&#34;0&#34;, &#34;1&#34;]].
        DEFAULT: None
    is_nan: bool = False
        True means NaN values are used, False means nan values are not used.
        DEFAULT: FALSE
    is_reduction: bool = True
        Is the reduction table used?
        DEFAULT: TRUE
    min_stable_attributes: int = 1
        Minimal number of stable pairs.
        DEFAULT: 1
    min_flexible_attributes: int = 1
        Minimal number of flexible pairs.
        DEFAULT: 1
    max_stable_attributes: int = 5
        Maximal number of stable pairs.
        DEFAULT: 5
    max_flexible_attributes: int = 5
        Maximal number of flexible pairs.
        DEFAULT: 5
    &#34;&#34;&#34;
    if (self.action_rules):
        raise Exception(&#34;Fit was already called&#34;)
    self.stable_attributes = stable_attributes
    self.flexible_attributes = flexible_attributes
    self.consequent = consequent
    if bool(desired_classes) != bool(desired_changes):
        self.desired_state = DesiredState(desired_classes=desired_classes, desired_changes=desired_changes)
    else:
        raise Exception(&#34;Desired classes or desired changes must be entered&#34;)
    attributes = stable_attributes + flexible_attributes
    self._check_columns(attributes, consequent)
    stable = self.decisions.data[stable_attributes]
    flex = self.decisions.data[flexible_attributes]
    target = self.decisions.data[[consequent]]
    supp_df = self.decisions.data[[supp_col]]
    supp_series = supp_df.iloc[:, 0]
    supp = supp_series.tolist()
    conf_df = self.decisions.data[[conf_col]]
    conf_series = conf_df.iloc[:, 0]
    conf = conf_series.tolist()
    reduced_tables = Reduction(stable, flex, target, self.desired_state, supp, conf, is_nan)
    if is_reduction:
        reduced_tables.reduce()
    self.action_rules = ActionRules(
        reduced_tables.stable_tables,
        reduced_tables.flexible_tables,
        reduced_tables.decision_tables,
        self.desired_state,
        reduced_tables.supp,
        reduced_tables.conf,
        is_nan,
        min_stable_attributes,
        min_flexible_attributes,
        max_stable_attributes,
        max_flexible_attributes
    )
    self.action_rules.fit()</code></pre>
</details>
</dd>
<dt id="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.get_action_rules"><code class="name flex">
<span>def <span class="ident">get_action_rules</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get machine representations of action rules.</p>
<p>The output is a list of action
rules. Each action rule is a list where the first part is an action rule itself, and the second part is
a tuple of (support before, support after, action rule support), (confidence before, confidence after, action
rule confidence) and uplift.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Returns list of action rules.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_action_rules(self) -&gt; list:
    &#34;&#34;&#34;Get machine representations of action rules.

    The output is a list of action
    rules. Each action rule is a list where the first part is an action rule itself, and the second part is
    a tuple of (support before, support after, action rule support), (confidence before, confidence after, action
    rule confidence) and uplift.

    Returns
    -------
    list
        Returns list of action rules.
    &#34;&#34;&#34;
    return self.action_rules.action_rules</code></pre>
</details>
</dd>
<dt id="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.get_action_rules_representation"><code class="name flex">
<span>def <span class="ident">get_action_rules_representation</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get math representation of action rules.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Returns list of action rules.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_action_rules_representation(self) -&gt; list:
    &#34;&#34;&#34;Get math representation of action rules.

    Returns
    -------
    list
        Returns list of action rules.
    &#34;&#34;&#34;
    if len(self.action_rules.action_rules_representation) == 0:
        self.action_rules.representation()
    return self.action_rules.action_rules_representation</code></pre>
</details>
</dd>
<dt id="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.get_pretty_action_rules"><code class="name flex">
<span>def <span class="ident">get_pretty_action_rules</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get human-readable representations of action rules.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Returns list of action rules.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pretty_action_rules(self) -&gt; list:
    &#34;&#34;&#34;Get human-readable representations of action rules.

    Returns
    -------
    list
        Returns list of action rules.
    &#34;&#34;&#34;
    if len(self.action_rules.action_rules_pretty_text) == 0:
        self.action_rules.pretty_text()
    return self.action_rules.action_rules_pretty_text</code></pre>
</details>
</dd>
<dt id="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.get_source_data_for_ar"><code class="name flex">
<span>def <span class="ident">get_source_data_for_ar</span></span>(<span>self, action_r_number, is_before)</span>
</code></dt>
<dd>
<section class="desc"><p>Get data frame with values which the action rule is based on.</p>
<p>Yellow background - stable attributes
Orange background - flexible attributes
Red text - Target attribute, undesired state
Green text - Target attribute, desired state</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>action_r_number</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of action rule - you can figure out from get_action_rules</dd>
<dt><strong><code>is_before</code></strong> :&ensp;<code>bool</code></dt>
<dd>True shows instances in data that match the conditions of the "before" part of the action rule.
False show instances in data that match the conditions of the "after" part of the action rule.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>Returns data frame with transactions data.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_source_data_for_ar(self, action_r_number: int, is_before: bool) -&gt; pd.DataFrame:
    &#34;&#34;&#34; Get data frame with values which the action rule is based on.

    Yellow background - stable attributes
    Orange background - flexible attributes
    Red text - Target attribute, undesired state
    Green text - Target attribute, desired state

    Parameters
    ----------
    action_r_number : int
        The number of action rule - you can figure out from get_action_rules
    is_before : bool
        True shows instances in data that match the conditions of the &#34;before&#34; part of the action rule.
        False show instances in data that match the conditions of the &#34;after&#34; part of the action rule.

    Returns
    -------
    pd.DataFrame
        Returns data frame with transactions data.
    &#34;&#34;&#34;
    if is_before:
        classification = self.action_rules.classification_before[action_r_number]
    else:
        classification = self.action_rules.classification_after[action_r_number]
    decision = self.decisions.decision_table.loc[
        classification, self.stable_attributes + self.flexible_attributes]
    source_table = self._reduce_table_source(decision, self.decisions.data)
    return source_table.style.applymap(lambda x: &#39;background-color: yellow&#39;,
                                       subset=self.stable_attributes) \
        .applymap(lambda x: &#39;background-color: orange&#39;,
                  subset=self.flexible_attributes) \
        .applymap(lambda x: &#39;color: green&#39; if x in self.desired_state.get_destination_classes() else &#39;color: red&#39;,
                  subset=[self.consequent])</code></pre>
</details>
</dd>
<dt id="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.load_pandas"><code class="name flex">
<span>def <span class="ident">load_pandas</span></span>(<span>self, data_frame)</span>
</code></dt>
<dd>
<section class="desc"><p>Loads a data frame.</p>
<p>It must be the Pandas data frame.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data_frame</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Pandas data frame.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_pandas(self, data_frame: pd.DataFrame):
    &#34;&#34;&#34;Loads a data frame.

    It must be the Pandas data frame.

    Parameters
    ----------
    data_frame : pd.DataFrame
        Pandas data frame.
    &#34;&#34;&#34;
    self.decisions.load_pandas(data_frame)</code></pre>
</details>
</dd>
<dt id="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, source_table)</span>
</code></dt>
<dd>
<section class="desc"><p>Predicts if any values would need to change their state.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>source_table</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>A data frame with new observations.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>Returns a data frame with recommended actions.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict(self, source_table: pd.DataFrame) -&gt; pd.DataFrame:
    &#34;&#34;&#34; Predicts if any values would need to change their state.

    Parameters
    ----------
    source_table : pd.DataFrame
        A data frame with new observations.

    Returns
    -------
    pd.DataFrame
        Returns a data frame with recommended actions.
    &#34;&#34;&#34;
    i = 0
    full_predicted_table = pd.DataFrame()
    for classification_before in self.action_rules.classification_before:
        classification_after = self.action_rules.classification_after[i]
        decision_before = self.decisions.decision_table.loc[
            classification_before, self.stable_attributes + self.flexible_attributes]
        decision_after = self.decisions.decision_table.loc[
            classification_after, self.stable_attributes + self.flexible_attributes]
        predicted_table = self._reduce_table_source(decision_before, source_table)
        if len(predicted_table.index) &gt; 0:
            for key, value in decision_after.items():
                if str(value) != &#34;nan&#34; and key in self.flexible_attributes:
                    column = key + self.RECOMMENDED
                    predicted_table[column] = [value] * len(predicted_table.index)
                    predicted_table[self.ACTION_RULE] = [i] * len(predicted_table.index)
                    predicted_table = predicted_table.astype({self.ACTION_RULE: int})
            predicted_table[self.ACTION_RULE_TARGET] = \
                [self.action_rules.action_rules[i][0][2][1][1]] * len(predicted_table.index)
            predicted_table[self.SUPPORT_BEFORE] = \
                [self.action_rules.action_rules[i][1][0]] * len(predicted_table.index)
            predicted_table[self.SUPPORT_AFTER] = \
                [self.action_rules.action_rules[i][1][1]] * len(predicted_table.index)
            predicted_table[self.ACTION_RULE_SUPPORT] = \
                [self.action_rules.action_rules[i][1][2]] * len(predicted_table.index)
            predicted_table[self.CONFIDENCE_BEFORE] = \
                [self.action_rules.action_rules[i][2][0]] * len(predicted_table.index)
            predicted_table[self.CONFIDENCE_AFTER] = \
                [self.action_rules.action_rules[i][2][1]] * len(predicted_table.index)
            predicted_table[self.ACTION_RULE_CONFIDENCE] = \
                [self.action_rules.action_rules[i][2][2]] * len(predicted_table.index)
            predicted_table[self.ACTION_RULE_UPLIFT] = \
                [self.action_rules.action_rules[i][3]] * len(predicted_table.index)
        full_predicted_table = pd.concat([full_predicted_table, predicted_table], sort=True)
        i += 1
    # New columns always in the end
    cols = full_predicted_table.columns.tolist()
    if len(cols)&gt;0:
        cols.append(cols.pop(cols.index(self.ACTION_RULE)))
        cols.append(cols.pop(cols.index(self.ACTION_RULE_TARGET)))
        cols.append(cols.pop(cols.index(self.SUPPORT_BEFORE)))
        cols.append(cols.pop(cols.index(self.SUPPORT_AFTER)))
        cols.append(cols.pop(cols.index(self.ACTION_RULE_SUPPORT)))
        cols.append(cols.pop(cols.index(self.CONFIDENCE_BEFORE)))
        cols.append(cols.pop(cols.index(self.CONFIDENCE_AFTER)))
        cols.append(cols.pop(cols.index(self.ACTION_RULE_CONFIDENCE)))
        cols.append(cols.pop(cols.index(self.ACTION_RULE_UPLIFT)))
        full_predicted_table = full_predicted_table[cols]
    return full_predicted_table</code></pre>
</details>
</dd>
<dt id="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.read_csv"><code class="name flex">
<span>def <span class="ident">read_csv</span></span>(<span>self, file, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Imports data from a CSV file.</p>
<p>It uses the same optional parameters as read_csv from Pandas.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file</code></strong> :&ensp;<code>str</code></dt>
<dd>A path to a file.</dd>
</dl>
<p>**kwargs :
Arbitrary keyword arguments (the same as in Pandas).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_csv(self, file: str, **kwargs):
    &#34;&#34;&#34;Imports data from a CSV file.

    It uses the same optional parameters as read_csv from Pandas.

    Parameters
    ----------
    file : str
        A path to a file.
    **kwargs :
        Arbitrary keyword arguments (the same as in Pandas).
    &#34;&#34;&#34;
    self.decisions.read_csv(file, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="actionrules.actionRulesDiscovery" href="index.html">actionrules.actionRulesDiscovery</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery" href="#actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery">ActionRulesDiscovery</a></code></h4>
<ul class="">
<li><code><a title="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.ACTION_RULE" href="#actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.ACTION_RULE">ACTION_RULE</a></code></li>
<li><code><a title="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.ACTION_RULE_CONFIDENCE" href="#actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.ACTION_RULE_CONFIDENCE">ACTION_RULE_CONFIDENCE</a></code></li>
<li><code><a title="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.ACTION_RULE_SUPPORT" href="#actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.ACTION_RULE_SUPPORT">ACTION_RULE_SUPPORT</a></code></li>
<li><code><a title="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.ACTION_RULE_TARGET" href="#actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.ACTION_RULE_TARGET">ACTION_RULE_TARGET</a></code></li>
<li><code><a title="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.ACTION_RULE_UPLIFT" href="#actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.ACTION_RULE_UPLIFT">ACTION_RULE_UPLIFT</a></code></li>
<li><code><a title="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.CONFIDENCE_AFTER" href="#actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.CONFIDENCE_AFTER">CONFIDENCE_AFTER</a></code></li>
<li><code><a title="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.CONFIDENCE_BEFORE" href="#actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.CONFIDENCE_BEFORE">CONFIDENCE_BEFORE</a></code></li>
<li><code><a title="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.RECOMMENDED" href="#actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.RECOMMENDED">RECOMMENDED</a></code></li>
<li><code><a title="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.SUPPORT_AFTER" href="#actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.SUPPORT_AFTER">SUPPORT_AFTER</a></code></li>
<li><code><a title="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.SUPPORT_BEFORE" href="#actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.SUPPORT_BEFORE">SUPPORT_BEFORE</a></code></li>
<li><code><a title="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.fit" href="#actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.fit">fit</a></code></li>
<li><code><a title="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.fit_classification_rules" href="#actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.fit_classification_rules">fit_classification_rules</a></code></li>
<li><code><a title="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.get_action_rules" href="#actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.get_action_rules">get_action_rules</a></code></li>
<li><code><a title="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.get_action_rules_representation" href="#actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.get_action_rules_representation">get_action_rules_representation</a></code></li>
<li><code><a title="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.get_pretty_action_rules" href="#actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.get_pretty_action_rules">get_pretty_action_rules</a></code></li>
<li><code><a title="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.get_source_data_for_ar" href="#actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.get_source_data_for_ar">get_source_data_for_ar</a></code></li>
<li><code><a title="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.load_pandas" href="#actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.load_pandas">load_pandas</a></code></li>
<li><code><a title="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.predict" href="#actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.predict">predict</a></code></li>
<li><code><a title="actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.read_csv" href="#actionrules.actionRulesDiscovery.actionRulesDiscovery.ActionRulesDiscovery.read_csv">read_csv</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>